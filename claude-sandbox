#!/usr/bin/env bash
set -euo pipefail

SANDBOX_DIR="${HOME}/.local/share/claude-sandbox"
SANDBOX_HOME="${HOME}/.claude-sandbox-home"
SANDBOX_SIF="${SANDBOX_DIR}/claude-sandbox.sif"

# Per-user tmp base directory (avoid conflicts with other users)
SANDBOX_TMP_BASE="/tmp/claude-sandbox-${UID}"

# Instance-specific tmp directory (set in run_container)
SANDBOX_TMP=""

# Cleanup temp directory on exit
cleanup() {
    if [ -n "${SANDBOX_TMP}" ] && [ -d "${SANDBOX_TMP}" ]; then
        rm -rf "${SANDBOX_TMP}"
        # Remove base dir if empty (ignore failure if other instances exist)
        rmdir "${SANDBOX_TMP_BASE}" 2>/dev/null || true
    fi
}
trap cleanup EXIT

# Initialize persistent home directory
init_sandbox_home() {
    mkdir -p "${SANDBOX_HOME}"/{.local/bin,.local/share/uv,.config,.claude}

    if [ ! -f "${SANDBOX_HOME}/.bashrc" ]; then
        cat > "${SANDBOX_HOME}/.bashrc" << 'EOF'
export PATH="$HOME/.local/bin:$PATH"
export UV_TOOL_DIR="$HOME/.local/share/uv/tools"
export UV_TOOL_BIN_DIR="$HOME/.local/bin"
export UV_PROJECT_ENVIRONMENT=.venv-sandbox

# Install claude-monitor on first run
if ! command -v claude-monitor &> /dev/null; then
    echo "Installing claude-monitor..."
    uv tool install claude-monitor 2>/dev/null || true
fi
EOF
    fi
}

# Build container
build_container() {
    echo "Building Claude sandbox container..."
    mkdir -p "${SANDBOX_DIR}"

    # Try unprivileged build first, fall back to fakeroot
    if ! apptainer build --fix-perms "${SANDBOX_SIF}" "${SANDBOX_DIR}/claude-sandbox.def" 2>/dev/null; then
        echo "Trying with --fakeroot..."
        apptainer build --fakeroot "${SANDBOX_SIF}" "${SANDBOX_DIR}/claude-sandbox.def"
    fi
    echo "Container built: ${SANDBOX_SIF}"
}

# Detect Julia installation path
detect_julia() {
    local julia_bin julia_home
    julia_bin=$(which julia 2>/dev/null) || true
    if [ -n "${julia_bin}" ]; then
        julia_home=$(dirname "$(dirname "$(readlink -f "${julia_bin}")")")
        # Skip system-installed Julia to avoid shadowing container's /usr
        if [ "${julia_home}" != "/usr" ] && [ "${julia_home}" != "/usr/local" ]; then
            echo "${julia_home}"
            return
        fi
    fi

    # Fallback: ask Julia for its actual location (handles juliaup wrappers)
    if command -v julia &>/dev/null; then
        julia_home=$(julia --startup-file=no -e 'println(dirname(Sys.BINDIR))' 2>/dev/null) || true
        if [ -n "${julia_home}" ] && [ -x "${julia_home}/bin/julia" ]; then
            echo "${julia_home}"
        fi
    fi
}

# Run container
run_container() {
    [ ! -f "${SANDBOX_SIF}" ] && { echo "Run 'claude-sandbox --build' first"; exit 1; }
    init_sandbox_home

    # Create per-instance temp directory (cleaned up on exit via trap)
    mkdir -p "${SANDBOX_TMP_BASE}"
    chmod 700 "${SANDBOX_TMP_BASE}"  # Restrict to owner only
    SANDBOX_TMP=$(mktemp -d "${SANDBOX_TMP_BASE}/instance.XXXXXX")

    local OPTS=(
        --containall --cleanenv --userns --nv
        --home "${SANDBOX_HOME}:/home/sandbox"
        --pwd "$(pwd)"
        --bind "${SANDBOX_TMP}:/tmp"
    )

    # Working directory bind is added later (after Julia binds) to ensure
    # it takes precedence when working inside ~/.julia/

    # GitHub CLI credentials (copy to writable temp location - gh needs write access for migrations)
    if [ -d "${HOME}/.config/gh" ]; then
        mkdir -p "${SANDBOX_TMP}/.config/gh"
        cp -r "${HOME}/.config/gh/"* "${SANDBOX_TMP}/.config/gh/"
        OPTS+=(--env "GH_CONFIG_DIR=/tmp/.config/gh")
    fi

    # Julia packages and installation
    # Bind to sandbox home for normal access, AND to original host path so
    # hardcoded paths in precompiled cache/deps files still work
    if [ -d "${HOME}/.julia" ]; then
        OPTS+=(--bind "${HOME}/.julia:/home/sandbox/.julia")
        # Also expose at original host path so hardcoded paths in precompilation
        # cache/deps files still resolve (e.g., PyCall conda, artifact paths)
        [ "${HOME}" != "/home/sandbox" ] && OPTS+=(--bind "${HOME}/.julia:${HOME}/.julia")
    fi
    local julia_home; julia_home=$(detect_julia)
    # Only bind Julia install if it's not already under ~/.julia/ (which is already bound)
    if [ -n "${julia_home}" ] && [[ "${julia_home}" != "${HOME}/.julia"* ]]; then
        OPTS+=(--bind "${julia_home}:${julia_home}:ro")
    fi

    # UV Python installations (for PyCall and other Python-dependent Julia packages)
    [ -d "${HOME}/.local/share/uv/python" ] && OPTS+=(--bind "${HOME}/.local/share/uv/python:${HOME}/.local/share/uv/python:ro")

    # Working directory - added after Julia binds so it takes precedence when inside ~/.julia/
    OPTS+=(--bind "$(pwd):$(pwd)")

    # Environment variables
    OPTS+=(--env "TERM=${TERM:-xterm-256color}")
    OPTS+=(--env "UV_PROJECT_ENVIRONMENT=.venv-sandbox")

    local git_name git_email
    git_name=$(git config --global user.name 2>/dev/null) || true
    git_email=$(git config --global user.email 2>/dev/null) || true
    [ -n "${git_name}" ] && OPTS+=(--env "GIT_AUTHOR_NAME=${git_name}" --env "GIT_COMMITTER_NAME=${git_name}")
    [ -n "${git_email}" ] && OPTS+=(--env "GIT_AUTHOR_EMAIL=${git_email}" --env "GIT_COMMITTER_EMAIL=${git_email}")

    # Set PATH (include Julia if detected)
    local container_path="/home/sandbox/.local/bin:/usr/local/bin:/usr/bin:/bin"
    if [ -n "${julia_home}" ]; then
        # Translate juliaup paths (under ~/.julia/) to the container home
        if [[ "${julia_home}" == "${HOME}/.julia"* ]]; then
            container_path="/home/sandbox/.julia${julia_home#"${HOME}/.julia"}/bin:${container_path}"
        else
            container_path="${julia_home}/bin:${container_path}"
        fi
    fi
    OPTS+=(--env "PATH=${container_path}")

    exec apptainer run "${OPTS[@]}" "${SANDBOX_SIF}" "$@"
}

case "${1:-}" in
    --build) build_container ;;
    --help|-h) echo "Usage: claude-sandbox [--build|--help] [CLAUDE_ARGS...]" ;;
    *) run_container "$@" ;;
esac
